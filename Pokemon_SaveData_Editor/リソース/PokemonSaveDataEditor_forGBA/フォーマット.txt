♪注意：情報の転載について
　流した情報に責任を持つため，この情報に基づいた情報を流すときは，私，ψ（プサ
イ）への連絡先（メール：psi@science.mi.to　ブログ：http://ledyba.ddo.jp/）を明記
してください．
　なお，責任持つと言っても，利用は自己責任で使ってください．出来うる限り早く間違
いを訂正する，という意味での責任です．

♪情報の正確さについて
　とりあえず改変出来ているので間違いは無いと思いますが，必ずしも正しいとは限りま
せん．ご了承願います．
　間違っているところは教えていただけると幸いです．

♪参考にしたところ
　エメラルド チケット差分修正ツール
　http://www.h6.dion.ne.jp/~taka.999/index.html
　の「あとがき」（http://www.h6.dion.ne.jp/~taka.999/page002.html）を参考にさせ
ていただきました（特にブロックデータのチェックサム！）．ありがとうございました．
しかし，残念ながらこのサイトの情報は一部間違っているところもあります．それらを修
正して纏めたのが以下です．


☆ポケモンセーブデータのデータフォーマット☆

♪全体のデータ構成
　ポケモンのセーブデータにおいてデータは以下のように並んでいます．

[a回目のセーブ](0x00000000 -> 0x0000dfff)
[b回目のセーブ](0x0000e000 -> 0x0001bfff)
[最終データ　 ](0x0001c000 -> 0x0001ffff)

※|a-b|=1

♪各セーブデータ
　各セーブデータに関しては，0x00から0x0dまでの「ブロックデータ」がある番号から始
まり，ローテートしていって一周して終わります．
たとえば

[0x0b][0x0c][0xd][0x0][0x1][0x2]・・・[0x09][0x0a]

という感じです．

♪ブロックデータ
　セーブデータには，ある単位で区切られた一かたまりがあります．以下，「ブロック
データ」と呼びます．
　ブロックデータおきにチェックサムなどを計算します．

１：ブロックデータの基本的構造
0x0000 -> 0x0ff3：実際のデータ
0x0ff4 -> 0x0fff：フッタ

２：フッタの構造
0xff4         ：ブロックナンバー（0x00 -> 0x0d 後述）
0xff5         ：定数(0x00)
0xff6 -> 0xff7：チェックサム
0xff8 -> 0x00b：定数(0x08012025)
0xffc -> 0xffd：セーブ回数
0xffe -> 0xfff：定数(0x0000)

３：チェックサム計算方法

３−１：4バイトごとに足し算
　0xff4までについて，4バイトごとに足し算を行います．

３−２：2バイトに変更する
　３−１で出た数字を上下で二つの2バイトの数値に変更し，足し算をおこないます．
　これがチェックサムです．

♪セーブ回数カウントによるブロックの並びの変化
第１回：[0x00]から
第２回：[0x0d]から

と一つづつ戻っていきます．一般的にｎ回目は
(0x0e-((n-0x0e)%0x0e)) % 0x0e
のブロックから始まります．
　しかし，途中でズレてしまう事もあるようです．最初のほうはこれであっているんです
が・・・．ブロックの並び順はセーブデータのチェックに引っかかるかと関係ないので，
妥協しました．

♪最終データのデータ構成
0x1c000->0x1cfff：殿堂入りデータその１
0x1d000->0x1dfff：殿堂入りデータその２
		　（以上はチェックサム計算を二つに分けているだけです．）

0x1e000->0x1efff：ブランクデータ（？）
		　今のところ0xfか0x00が書かれているのしか見た事がない．

0x1f000->0x1ffff：Emの場合は対戦ログ関連のデータ
		　その他バージョンではブランクデータ

♪殿堂入りデータの構成
１：おおまなか構造
0x0000 -> 0x0ff3：実際のデータ
0x0ff4 -> 0x0fff：フッタ
ブロックデータと同じですが，フッタが異なります．

２：フッタの構造
0xff4 -> 0xff5：チェックサム
0xff6 -> 0xff7：定数(0x0000)
0xff8 -> 0x00b：定数(0x08012025)
0xffc -> 0xfff：定数(0x00000000)

３：チェックサム計算
計算方法はブロックデータと一緒です．

♪Em対戦ログ関連データの構成

　適当にいじると対戦データが見れなくなる，という実験結果より，最後の4KByesは通信
対戦のログ関係のデータであると思われます．
（対戦者の名前が見つけられないので，
				自分のポケモンのデータかと思わますが，さて？）

以下のように構成されます．
0x000 -> 0x003：定数（=0x0000b39d）
0x004 -> 0x47f：データ
0x480 -> 0x483：よくわからないチェック（後述）
0x484 -> 0xf7f：データ
0xf80 -> 0xf83：チェックサム
0xf84 -> 0xfff：ブランクデータ

１：チェックサム計算方法
0x004から0xf7fまでの数値についてByteごとの足し算を行います．（ケタは4バイト分確
保されているので，繰り上がることも当然ありえます）

これがチェックサムです．ブロックデータに比べ，とてもシンプルです．

２：よくわからないチェック
　以下のチェックにかけ，合格しなければ「データはありません」になります．

　0x480 -> 0x483のデータを仮にAとすると，
(A != 0) && ((A  & 0x7d007e92) == 0)
がtrueでなければ「データはありません」となります．

　普段プログラミングをやらない方のために自然言語で説明すると，
・Aが0でない
・Aと0x7d007e92のandが0である
　これが両方とも成り立たないと「データはありません」です．

　ここのデータについてはいじらないほうが良さそうです．しかし・・・存在意義がよく
わかりません．これ以上の解析が済んだ方はぜひ教えていただけるとありがたいです．
